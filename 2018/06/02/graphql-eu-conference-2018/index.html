<!DOCTYPE html>



 <html class="no-js"> 
<head>
    <title>GraphQL EU Conference 2018 &middot; INFOVERLOAD</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="content-language" content="en-us" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="author" content="Infoverload">
    <meta name="description" content="My personal blog">
    <meta name="generator" content="Hugo 0.40.2" />

    <!-- Stylesheets -->
    <link rel="stylesheet" type="text/css" href="https://infoverload.github.io/css/main.css" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/tomorrow.min.css" />
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:400italic,400,300,700|Lora:400,700,400italic" rel="stylesheet" type="text/css">
    
</head>

<body>
    
    <div class="off-canvas">
    <figure class="avatar">
        <img src="https://infoverload.github.io/img/avatar.jpg" title="Infoverload">
    </figure>
    <div class="bio">
        
        <h1>Hi, I&#39;m Daisy</h1>
        
        
        <p>Here is a place for my random musings!</p>
        
    </div>
    <nav>

        

        
        <h6>Subscribe</h6>
        

        <ul>
            <li><a target="_blank" href="https://infoverload.github.io/index.xml">RSS feed</a></li>
        </ul>

        
        <h6>Follow me on</h6>
        

        <ul>
        
            <li><a target="_blank" href="//twitter.com/1nfoverload">Twitter</a></li>
        
            <li><a target="_blank" href="//github.com/infoverload">GitHub</a></li>
        
        </ul>        
    </nav>
</div>


    <div class="site-wrapper">
        <header>
	<div class="h-wrap">
		
		<h1 class="title"><a href="https://infoverload.github.io/">INFOVERLOAD</a></h1>
		
		<a class="menu-icon" title="Menu"><span class="lines"></span></a>
	</div>
</header>
        
        <section class="single-wrap">
            <article class="single-content" itemscope itemtype="//schema.org/BlogPosting">
                <div class="feat">
                    <h5 class="page-date">
                    <time datetime="" itemprop="datePublished">
                    2. June 2018
                    </time>
                    </h5>
                </div>
                <h1 class="page-title" itemprop="name headline">GraphQL EU Conference 2018</h1>
                <div itemprop="articleBody">
                    

<p>I had the wonderful opportunity to attend the GraphQL EU Conference in Berlin this summer, which is the second conference surrounding GraphQL. There were apparently double the amount of attendees this year compared to last year! There were a ton of interesting and exciting talks surrounding its current usage, and best practices and wisdom from companies who are already adopting GraphQL. I particularly enjoyed the talk &ldquo;Revenge of the Monolith&rdquo; by Nick Schrock, where he goes through the history of GraphQL at Facebook and how it came to be open-source and dispelled a bit of the hype over microservices.</p>

<p>GraphQL is a really exciting technology and one that I also spent time digging a bit deeper into. This post will go over how to replace rest APIs with GraphQL!</p>

<p>As you may already know, the current dominant architecture style for client-server interaction is REST (Representational State Transfer) and when people talk about APIs, they generally refer to REST APIs. If you have thought about obtaining data from another resource on the Internet with your application, you have probably come across this term or written an app that consumes REST APIs.</p>

<p>REST dictates a set of guidelines that should be followed during API creation. For example, in order to request or update resources, different URLs are used. All calls should be stateless, and are typically transferred through a client-server protocol such as HTTP. Objects on the server are treated as resources that can be created or deleted.</p>

<p>As ubiquitous as REST APIs are, they are not without problems. First, there is the problem with latency. Since interactions are with a single entity type per HTTP request, this necessitates multiple round-trips between the client and the server in order to traverse the object. You have to go through each URL and make a request for each. Second, there is the problem with inconsistency. There is no standard way to build REST APIs and with this flexibility comes a downside. Oftentimes, the designated endpoints become arbitrary code that takes in parameters accessed via HTTP requests and spits back out any data. This can lead to inconsistent code bases. Third, there is little transparency. REST APIs often become a black box of sorts from the client-side’s standpoint. Documentation is often key to understanding how to leverage and understand the API.</p>

<p>Furthermore, the APIs can become difficult to manage at scale when endpoints start to grow rapidly and every resource becomes designated by a different URL. Lastly, there is no built-in data validation and every API is responsible for validating and cleaning the data.</p>

<p>Although REST may be the norm, there are other alternatives emerging such as GraphQL.</p>

<h3 id="what-is-graphql">What is GraphQL?</h3>

<p>GraphQL is a hierarchical and strongly typed data query language for APIs that is starting to gain popularity and has seen a lot of adoption from big companies like Facebook, GitHub, Yelp, Pinterest, Shopify due to its many benefits over REST APIs. It was developed internally at Facebook in 2012 and became open-source in 2015.</p>

<p>As Facebook was expanding, it encountered a lot of scaling problems as more and more microservices were created for so many different things and the problem of how to fetch data consistently from all these data sources arose. GraphQL was created to combine all the different data sources into a single API.</p>

<p>GraphQL is comprised of a query language and a framework that processes those queries. It is language agnostic and can be implemented in any environment. It offers a lot of benefits over traditional REST APIs. Importantly, GraphQL alleviates the problem of over-fetching and under-fetching data by allowing the client to declare exactly what data is necessary. The server will return exactly that and nothing more. It is a declarative and strongly typed system that returns predictable results. The client specifies the structure of the data desired in the query and the response is returned by the server in the same structure.</p>

<p>In addition, it solves classic performance problems by avoiding multiple calls to the server. GraphQL enables the client to issue just a single request to the GraphQL server while declaring the use of multiple resources in potentially complex nested hierarchical data. The server understands how to handle relationships and unify all the different endpoints by federating all the requests (made by that one query) to the different REST resources that have been previously defined and deciding what is actually necessary to return. The work of processing and filtering has been offloaded to the server.</p>

<p>With all of the advantages of GraphQL, it should be noted that GraphQL is just a query language specification that can be implemented with a variety of languages and so setting up a GraphQL server can be a challenging task. That is why there have been a few GraphQL-as-a-service platforms created such as Graphcool and Scaphold.</p>

<p>Moreover, since queries are no longer idempotent, GraphQL results can’t make good use of HTTP caching like REST API results. The solution would be client-side caching, which can be achieved with tools like Relay and Apollo. Queries could be minimized with all the data on the client side.</p>

<p>There are some security concerns to be mindful of against malicious queries that target the deeply nested nature of queries. This can be mitigated with timeouts, query depth limits, and query complexity limits (i.e. defining a maximum complexity that can be queried).</p>

<h3 id="transitioning-to-graphql">Transitioning to GraphQL</h3>

<p>The GraphQL approach to creating APIs is quite different from the way of developing REST APIs. First and foremost, you will need to choose a GraphQL implementation for the server component. There are many to choose from in the most popular programming languages: <a href="http://graphql.org/code">http://graphql.org/code</a>. Then you will need to select a client component, which accepts queries from the frontend and connects to the GraphQL endpoint to make the request. The most popular options right now are Relay (from Facebook) and Apollo.</p>

<p>The key components to a GraphQL API are the schema (for your type definitions), resolvers, and queries.</p>

<h3 id="schemas">Schemas</h3>

<p>Unlike REST APIs, GraphQL relies on a schema that it queries when a request is made. The schema describes the data types of the API and defines what can be queried. A great thing about GraphQL’s approach is that as soon as a schema is created, so is the documentation. So you first have to generate a schema, which always begins with a root query.</p>

<p>A simple example:</p>

<pre><code>type RootQuery {
    post: Entry
}

type Entry {
    title: String
    content: String
}
</code></pre>

<p>Here the post field returns an Entry object and the Entry object consists of a title of type String and content also of type String. In a REST API, the list of endpoints would be similar to the fields on the query types in GraphQL since they are both the gateway into getting the resource.</p>

<p>A vital aspect of every field is a resolver, which dictates how to fetch the actual data.</p>

<p>For example:</p>

<pre><code>Query: {
    post(root, args) {
        return Posts.find({ id: args.id }); // the resolver
    }
}
</code></pre>

<p>Data can be fetched from anywhere, which enables GraphQL to act as a facade for your database, your cache, your services. A query language is essentially being built on top of your existing application code, which makes the transition so much smoother.</p>

<p>After you have finished creating your schema, the GraphQL server will expose your API via an endpoint. Only one endpoint is needed.</p>

<h3 id="querying-data">Querying Data</h3>

<p>A GraphQL query consists of an endpoint, a query declaration, and some fields (properties that define the shape of the response we get back).</p>

<p>Here a new query is being declared asking for a field called post:</p>

<pre><code>query {
    post{
        title
        content
    }
}
</code></pre>

<p>The potential JSON response (which is in the same shape as the query):</p>

<pre><code>{
    “data”: {
    “post”: {
        “title”: “First Post”,
        “content”: “Here is some content”
        }
    }
}
</code></pre>

<p>A query can also accept arguments:</p>

<pre><code>query {
    post(id: 1) {
        title
        content
    }
}
</code></pre>

<h3 id="modifying-data">Modifying Data</h3>

<p>Mutation is a reserved keyword in GraphQL for making modifications to your data. It is very similar to a query declaration, except that it makes changes to existing data.</p>

<p>A simple example that is supposed to allow you to create a new post:</p>

<pre><code>mutation {
    createPost(title: ‘New Post’, content: ‘New Content’) {
	title
        content
    }
}
</code></pre>

<h3 id="other-features">Other features</h3>

<p>There are still a lot of important and interesting elements of GraphQL that are not covered in this post, such as object identification, hypermedia, caching, directives, alias, fragments, arguments, nested fields (edges, nodes). The official documentation is an excellent resource.</p>

<h3 id="conclusion">Conclusion</h3>

<p>GraphQL is a very enticing project that provides a new way for clients and servers to interact in order to exchange data. GraphQL and REST APIs both have the same goals but GraphQL has made a few core changes that alters the way APIs are built and consumed and aims to improve on the ideas from REST architecture. Although it has many benefits over REST APIs, it will not serve everyone’s needs and purposes. REST is currently still the predominant architecture to follow when building APIs and it has the simplicity and integrations that GraphQL has yet to match. But there is a good chance that this will change in the near future.</p>

                </div>
                <div class="feat share">
                    <a href="//twitter.com/share" class="popup">
                        <span class="icon-twitter"></span>
                    </a>
                </div>
                
                

                
                    <a rel="next" href="https://infoverload.github.io/2018/08/08/promql-zine/" id="next">
                        <span class="nav-title nav-title-next">Newer</span> &rarr;
                    </a>
                
                
                    <a rel="prev" href="https://infoverload.github.io/2018/06/02/rustfest-paris-2018/" id="prev">
                        &larr; <span class="nav-title nav-title-prev">Older</span>
                    </a>
                
            </article>
        </section>

        <footer>
	
	<small>Powered by <a href="//gohugo.io">HUGO</a> - © 2018</small>
	
</footer>
    </div>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="https://infoverload.github.io/js/main.js"></script>




<!-- Syntax highlighting -->
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
