<!DOCTYPE html>



 <html class="no-js"> 
<head>
    <title>How to build a gRPC server and client in TypeScript &middot; INFOVERLOAD</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="content-language" content="en-us" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="author" content="Infoverload">
    <meta name="description" content="My personal blog">
    <meta name="generator" content="Hugo 0.40.2" />

    <!-- Stylesheets -->
    <link rel="stylesheet" type="text/css" href="https://infoverload.github.io/css/main.css" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/tomorrow.min.css" />
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:400italic,400,300,700|Lora:400,700,400italic" rel="stylesheet" type="text/css">
    
</head>

<body>
    
    <div class="off-canvas">
    <figure class="avatar">
        <img src="https://infoverload.github.io/img/avatar.jpg" title="Infoverload">
    </figure>
    <div class="bio">
        
        <h1>Hi, I&#39;m Daisy</h1>
        
        
        <p>Here is a place for my random musings!</p>
        
    </div>
    <nav>

        

        
        <h6>Subscribe</h6>
        

        <ul>
            <li><a target="_blank" href="https://infoverload.github.io/index.xml">RSS feed</a></li>
        </ul>

        
        <h6>Follow me on</h6>
        

        <ul>
        
            <li><a target="_blank" href="//twitter.com/1nfoverload">Twitter</a></li>
        
            <li><a target="_blank" href="//github.com/infoverload">GitHub</a></li>
        
        </ul>        
    </nav>
</div>


    <div class="site-wrapper">
        <header>
	<div class="h-wrap">
		
		<h1 class="title"><a href="https://infoverload.github.io/">INFOVERLOAD</a></h1>
		
		<a class="menu-icon" title="Menu"><span class="lines"></span></a>
	</div>
</header>
        
        <section class="single-wrap">
            <article class="single-content" itemscope itemtype="//schema.org/BlogPosting">
                <div class="feat">
                    <h5 class="page-date">
                    <time datetime="" itemprop="datePublished">
                    19. July 2019
                    </time>
                    </h5>
                </div>
                <h1 class="page-title" itemprop="name headline">How to build a gRPC server and client in TypeScript</h1>
                <div itemprop="articleBody">
                    

<h3 id="grpc">gRPC</h3>

<p><a href="https://grpc.io">gRPC</a> is an open-source RPC framework that makes communication over the network performant and scalable by taking advantage of binary formats through leveraging HTTP/2 features for transporting and using <a href="https://developers.google.com/protocol-buffers/">protocol buffers</a> (out of the box) for serializing data. It supports generating server and client bindings in many languages across many platforms. Common use cases include connecting microservices, connecting mobile devices to backend services, and optimizing container to container communication. Learn more <a href="https://www.grpc.io">here</a>.</p>

<h3 id="prisma-2">Prisma 2</h3>

<p><a href="https://www.prisma.io/blog/announcing-prisma-2-zq1s745db8i5"><strong>Prisma 2</strong></a> is an open-source project that provides an ecosystem for interacting with your data.  Anytime you need to connect to a data source or work with a database, Prisma 2 will be helpful since it provides tools to abstract your data to allow for scalable, explicit and declarative data access.</p>

<p>It features <a href="http://photonjs.prisma.io"><strong>Photon</strong></a> (which autogenerates a type-safe database client with a highly optimized query engine embedded) and <a href="http://lift.prisma.io"><strong>Lift</strong></a> (which allows you to declaratively model your database schema and get migrations autogenerated). These data tools can be used standalone or together and is compatible with many popular <a href="https://github.com/prisma/prisma2/blob/master/docs/supported-databases.md">databases</a>. They are a great fit for building REST &amp; gRPC APIs where it can be used in place of traditional ORMs.</p>

<h3 id="grpc-and-prisma2-in-combination">gRPC and Prisma2 in combination</h3>

<p>In this tutorial, we will build a basic gRPC server and client for a simple blog service in Typescript with the help of Prisma 2! We will use <a href="http://lift.prisma.io"><strong>Lift</strong></a> for database migrations and <a href="http://photonjs.prisma.io"><strong>Photon JS</strong></a> for database access.</p>

<h2 id="goals">Goals</h2>

<p>This tutorial will teach you how to:</p>

<p><a href="#1.-install-the-prisma-2-cli">1.</a> Install and use the tools in the Prisma 2 ecosystem</p>

<p><a href="#2.-define-the-grpc-service-and-message-types">2.</a> Define the gRPC service and message types</p>

<p><a href="#3.-define-a-prisma-schema-file">3.</a> Define a Prisma schema file</p>

<p><a href="#4.-migrate-your-database-schema-using-lift">4.</a> Migrate your database schema using Lift</p>

<p><a href="#5.-generate-the-database-client-(photon-js)">5.</a> Generate Photon JS to interact with your database</p>

<p><a href="#6.-write-our-grpc-server-and-client">6.</a> Write a basic gRPC server and client</p>

<p><a href="#7.-set-up-our-typescript-project">7.</a> Set up our Typescript project</p>

<h2 id="prerequisites">Prerequisites</h2>

<p>This tutorial assumes that you have some basic familiarity with:</p>

<ul>
<li>Typescript</li>
<li>Node.js</li>
</ul>

<p>We will use <strong>TypeScript</strong> with a <strong>MySQL</strong> database in this tutorial. You can set up your MySQL database locally or use a hosting provider such as <a href="https://elements.heroku.com/addons">Heroku</a> or <a href="https://www.digitalocean.com/community/tutorials/how-to-install-mysql-on-ubuntu-18-04">Digital Ocean</a>.</p>

<p>Make sure that your database server is <a href="https://tableplus.io/blog/2018/10/how-to-start-stop-restart-mysql-server.html">running</a>.</p>

<p>If you are running <a href="https://www.docker.com">Docker</a>, here is how you can get a MySQL server running quickly:</p>

<pre><code class="language-sh">export MYSQL_ROOT_PASSWORD=password
export MYSQL_PORT=33123
docker run --name prisma-mysql \
           -e MYSQL_ROOT_PASSWORD \
           -d -p $MYSQL_PORT:3306 mysql
</code></pre>

<p>The username defaults to <code>root</code> and the host defaults to <code>localhost</code>.
Now you can create a database by using the MySQL CLI tool that is included in the Docker container you just started:</p>

<pre><code class="language-sh">docker exec prisma-mysql mysql \
       -p&quot;$MYSQL_ROOT_PASSWORD&quot; \
       -e &quot;CREATE DATABASE database_name&quot;
</code></pre>

<p>To check that it worked:</p>

<pre><code class="language-sh">docker exec prisma-mysql mysql \
       -p&quot;$MYSQL_ROOT_PASSWORD&quot; \
       -e &quot;SHOW DATABASES&quot;
</code></pre>

<blockquote>
<p><strong>Note</strong>: If you don&rsquo;t want to set up a MySQL database, you can still follow along by choosing SQLite in the beginning. One of Prisma&rsquo;s main benefits is that it lets you easily swap out the data sources your application connects to by adjusting a few lines in your <a href="https://github.com/prisma/prisma2/blob/master/docs/prisma-schema-file.md">Prisma schema file</a>.</p>
</blockquote>

<p>Here is an overview of how it all fits together:</p>

<p><img src="https://i.imgur.com/M8YsdoEg.png" alt="" /></p>

<p>We will go through each section in detail. The example code for this tutorial is located in this <a href="https://gitlab.com/infoverload/grpc-server-client">repository</a>.</p>

<h2 id="1-install-the-prisma-2-cli">1. Install the Prisma 2 CLI</h2>

<p>The <a href="https://github.com/prisma/prisma2/blob/master/docs/prisma2-cli.md">Prisma 2 CLI</a> is available as the <a href="https://www.npmjs.com/package/prisma2"><code>prisma2</code></a> package on npm. You can install it as a global package on your machine with the following command:</p>

<pre><code class="language-sh">npm install -g prisma2
</code></pre>

<p>Alternatively, you can do a local install with</p>

<pre><code class="language-sh">npm install prisma2
</code></pre>

<p>You can then run <code>npx prisma2</code> instead of <code>prisma2</code>. <code>npx</code> is a wrapper to execute package binaries. It will check whether the command exists in $PATH, or in the local project binaries, and execute it.</p>

<blockquote>
<p><strong>Note</strong>: You can set up a new project with <code>prisma2 init</code>, follow the init process, and create a gRPC boilerplate, which provides a gRPC API example.  But we will go through a more stripped down <a href="https://gitlab.com/infoverload/grpc-server-client">version</a> in this tutorial and walk through the details.</p>
</blockquote>

<p>We will make use of the Prisma 2 CLI utilities after defining our gRPC service.</p>

<h2 id="2-define-the-grpc-service-and-message-types">2. Define the gRPC service and message types</h2>

<p>Like many RPC systems, gRPC is based around the idea of defining a service and specifying the methods that can be called remotely with their parameters and return types.</p>

<p>We need to first use protocol buffers to define our gRPC service and method request and response types in a  <code>.proto</code> file. You can follow along with the example <a href="https://gitlab.com/infoverload/grpc-server-client/blob/master/service.proto">here</a>.  We will use the <a href="https://developers.google.com/protocol-buffers/docs/proto3">proto3</a> version of the protocol buffers language.</p>

<h3 id="2-1-define-the-service">2.1 Define the service</h3>

<p>Let&rsquo;s define a blog service interface:</p>

<pre><code>service Blog {
  ...
}
</code></pre>

<p>Then define your RPC methods inside your blog service definition. During our implementation later, both the server and the client will have a <code>ShowFeed</code> RPC method that takes a <code>ShowFeedRequest</code> parameter from the client and returns a <code>Feed</code> response from the server:</p>

<pre><code>rpc ShowFeed(ShowFeedRequest) returns (Feed) {};
</code></pre>

<p>Let&rsquo;s add another method:</p>

<pre><code>rpc CreatePost(CreatePostRequest) returns (Post) {}
</code></pre>

<h3 id="2-2-define-the-message-type">2.2 Define the message type</h3>

<p>We also need to define the structure of the message payload for all the request and response types used in our service methods.</p>

<p>Let&rsquo;s define a message format for each <code>Post</code>, where each request has the following fields:</p>

<pre><code>message Post {
  string id = 1;
  string createdAt = 2;
  string updatedAt = 3;
  string title = 4;
  string content = 5;
  User author = 6;
}
</code></pre>

<p>Note that the type comes first and that <code>User</code> is a composite type. Each field in the message definition has a unique number, which are used to identify your fields in the message binary format, and should not be changed once your message type is in use.</p>

<p>Let&rsquo;s define our <code>Feed</code> message type:</p>

<pre><code>message Feed {
  repeated Post feed = 1;
}
</code></pre>

<p>Note that it has a field rule <code>repeated</code> for the <code>Post</code> type, which signifies that this field can be repeated any number of times. So our <code>Feed</code> will contain any number of <code>Posts</code>.</p>

<h2 id="3-define-a-prisma-schema-file">3. Define a Prisma schema file</h2>

<p>The schema file (<a href="https://gitlab.com/infoverload/grpc-server-client/blob/master/prisma/schema.prisma">example here</a>) holds the configurations for your Prisma setup and consists of data sources, a generator, and data model definitions.</p>

<h3 id="3-1-add-a-data-source-and-a-generator">3.1 Add a data source and a generator</h3>

<p>In <code>schema.prisma</code>, let&rsquo;s specify a data source (MySQL), which determines what native database type each of our data model types map to and a generator (Photon JS), which determines what type in the target programming language each of these types map to. Learn more <a href="https://github.com/prisma/prisma2/blob/master/docs/prisma-schema-file.md">here</a>.</p>

<pre><code>datasource mysql {
    provider = &quot;mysql&quot;
    url      = &quot;mysql://USER:PASSWORD@HOST:3306/DATABASE&quot;
}

generator photon {
    provider = &quot;photonjs&quot;
}
</code></pre>

<p>You can give your file any name but <code>schema.prisma</code> will be automatically detected by the Prisma 2 CLI. It&rsquo;s also possible to provision the <code>url</code> as an <a href="https://github.com/prisma/prisma2/blob/master/docs/prisma-schema-file.md#using-environment-variables">environment variable</a>.</p>

<h3 id="3-2-add-data-model-definitions">3.2 Add data model definitions</h3>

<p>Next, we define our <a href="https://github.com/prisma/prisma2/blob/master/docs/data-modeling.md">model definitions</a>. Models represent the entities of our application domain, define the underlying database schema, and is the foundation for the auto-generated CRUD operations of the database client.</p>

<p>Let&rsquo;s define a simple <code>User</code> and <code>Post</code> model to our schema file:</p>

<pre><code>model Post {
    id        String   @default(cuid()) @id @unique
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    title     String
    content   String?
    author    User?
}

model User {
    id       String  @default(cuid()) @id @unique
    email    String  @unique
    password String
    name     String?
    posts    Post[]
}
</code></pre>

<p><code>Post</code> and <code>User</code> will each be mapped to database tables. There is a <em>bidirectional</em> relation between <code>User</code> and <code>Post</code> via the <code>author</code> and <code>posts</code> field.  The fields will be mapped to columns of the tables.</p>

<p>Things to note:
- <code>@default</code> directive sets a default value
- <code>@default(cuid())</code> sets a default value for the field by generating a <a href="https://github.com/ericelliott/cuid"><code>cuid</code></a>
- <code>@id</code> and <code>@updatedAt</code> directives are managed by Prisma and read-only in the exposed Prisma API
- <code>@id</code> directive indicates that this field is used as the <em>primary key</em>
- <code>@unique</code> directive expresses a unique constraint which means that Prisma enforces that no two records will have the same values for that field
- <code>?</code> is a type modifier indicating that this field is <em>optional</em></p>

<p>If you change your datamodel, you can just regenerate your Prisma client and all typings will be updated.</p>

<h2 id="4-migrate-your-database-schema-using-lift">4. Migrate your database schema using Lift</h2>

<p>Now that we have defined our data model, we can map the data model to our database schema with <a href="http://lift.prisma.io">Lift</a>!</p>

<p>Every schema migration with Lift follows this process:
- [x] Adjust data model
  - Change your <a href="https://github.com/prisma/prisma2/blob/master/docs/data-modeling.md">data model definition</a> to match your desired database schema.
- [ ] Save migration
  - Run <code>prisma2 lift save</code> to create your <a href="https://github.com/prisma/prisma2/blob/master/docs/lift/migration-files.md">migration files</a> on the file system.
- [ ] Run migration
  - Run <code>prisma2 lift up</code> to perform the migration against your database.</p>

<blockquote>
<p><strong>Note</strong>: If you run into any issues, try switching on the debug mode with <code>export DEBUG=*</code>.  To switch off the debug mode, try <code>export DEBUG=&quot;&quot;</code>.</p>
</blockquote>

<h3 id="4-1-save-the-migration-files">4.1. Save the migration files</h3>

<p>With every database schema migration, Lift generates <a href="https://github.com/prisma/prisma2/blob/master/docs/lift/migration-files.md">migration files</a> and saves them on your file system. This allows you to maintain a migration history of your database and to rollback and replay as needed. A <code>_Migration</code> table is also generated in your database which stores the details of every migration.</p>

<p>Let&rsquo;s create and save our migrations files and give it a name:</p>

<pre><code>prisma2 lift save --name 'init'
</code></pre>

<p>This reads the data sources and data model defintions from our <code>schema.prisma</code> file and creates a <code>migrations</code> folder (tagged with &lsquo;init&rsquo;) on our system holding the first set of migration files:</p>

<pre><code>prisma2-grpc
└── prisma
    ├── migrations
    │   ├── 20190703131441-init
    │   │   ├── README.md
    │   │   ├── datamodel.prisma
    │   │   └── steps.json
    │   └── lift.lock
    └── schema.prisma
</code></pre>

<h3 id="4-2-perform-the-database-migration">4.2. Perform the database migration</h3>

<p>Now that we have our migration files, we can run the migration (create/write to our database):</p>

<pre><code>prisma2 lift up
</code></pre>

<p>This maps your data model to the underlying database schema.</p>

<p><img src="https://i.imgur.com/NoL7LsKg.png" alt="" /></p>

<p>In our example, these are some of the SQL queries that executed:</p>

<pre><code class="language-sql">CREATE TABLE `prisma2`.`Post`(
  `id` varchar(1000) NOT NULL  ,
  `createdAt` datetime(3) NOT NULL  ,
  `updatedAt` datetime(3) NOT NULL DEFAULT '1970-01-01 00:00:00' ,
  `title` varchar(1000) NOT NULL DEFAULT '' ,
  `content` varchar(1000),
  PRIMARY KEY (`id`));

CREATE TABLE `prisma2`.`User`(
  `id` varchar(1000) NOT NULL  ,
  `email` varchar(1000) NOT NULL DEFAULT '' ,
  `password` varchar(1000) NOT NULL DEFAULT '' ,
  `name` varchar(1000)   ,
  PRIMARY KEY (`id`));

CREATE UNIQUE INDEX `User.id._UNIQUE` ON `prisma2`.`User`(`id`);
</code></pre>

<blockquote>
<p>Note: Note that <code>updatedAt</code> is initiated by the <a href="https://en.wikipedia.org/wiki/Unix_time">Unix start time</a>.</p>
</blockquote>

<p>You can check the database steps in the README file in the <code>prisma/migrations</code> directory.</p>

<p>We can now access our database programmatically by generating a Photon API.</p>

<h2 id="5-generate-the-database-client-photon-js">5. Generate the database client (Photon JS)</h2>

<p><a href="http://photonjs.prisma.io">Photon</a> provides a type-safe data access API for our data model and is generated from our Prisma schema file with the <code>generator</code> definition:</p>

<pre><code>generator photonjs {
  provider = &quot;photonjs&quot;
}
</code></pre>

<p>Run the following command to generate Photon JS:</p>

<pre><code>prisma2 generate
</code></pre>

<p>This parses our Prisma schema file to generate the right data source client code and creates a <code>photon</code> directory inside <code>node_modules/@generated</code>:</p>

<pre><code>├── node_modules
│   └── @generated
│       └── photon
│           └── runtime
│               ├── index.d.ts
│               └── index.js
</code></pre>

<p>This is the default path but can be <a href="https://github.com/prisma/prisma2/blob/master/docs/photon/codegen-and-node-setup.md">customized</a>. It is best not to change the files in the generated directory because it will get overwritten.</p>

<p>Now we can import Photon in our code like this:</p>

<pre><code class="language-ts">import Photon from '@generated/photon'
</code></pre>

<h2 id="6-write-our-grpc-server-and-client">6. Write our gRPC server and client</h2>

<p>In Node.js, we can generate the code from our protocol buffers dynamically at runtime with <a href="https://www.npmjs.com/package/protobufjs">protobuf.js</a> or statically with a protocol buffer compiler <a href="https://github.com/protocolbuffers/protobuf/releases">protoc</a>. The behaviour in the end will be the same. Since we are using Typescript, we can safely leverage dynamically generated code and that is what we will use in this tutorial.</p>

<h3 id="6-1-write-our-server">6.1 Write our server</h3>

<p>For our <a href="https://gitlab.com/infoverload/grpc-server-client/blob/master/server.ts">server</a>, we will implement the methods declared by the service and run a gRPC server to handle client calls.</p>

<p>We will use the <a href="https://www.npmjs.com/package/@grpc/proto-loader">@grpc/proto-loader</a> library to load our <code>.proto</code> files with it&rsquo;s <code>loadSync</code> method and pass the output to the <a href="https://www.npmjs.com/package/grpc">gRPC library&rsquo;s</a> <code>loadPackageDefinition</code> method. The protobuf.js library dynamically generates service descriptors and client definitions from <code>.proto</code> files loaded at runtime.</p>

<pre><code class="language-ts">const PROTO_PATH = __dirname + '/service.proto'

import Photon from '@generated/photon'
import * as protoLoader from '@grpc/proto-loader'
import * as grpc from 'grpc'

const photon = new Photon()

const packageDefinition = protoLoader.loadSync(PROTO_PATH, {
  keepCase: true,
  longs: String,
  enums: String,
  defaults: true,
  oneofs: true,
})
const { protoDescriptor } = grpc.loadPackageDefinition(packageDefinition) as any
</code></pre>

<p>Our <code>protoDescriptor</code> object now has the full package hierarchy.</p>

<p>Let&rsquo;s implement the service interface from our service definition. We&rsquo;ll do a simple one and write the <code>showFeed</code> method, which simply accepts a callback to which we can return all the blog posts that has been fetched from the database with <code>findMany</code>, a method which is exposed for the <code>Post</code> model with the generated Photon API. Note that all of these methods are asynchronous and use callbacks so we can <code>await</code> the results of the operation.</p>

<pre><code class="language-ts">const showFeed = async(call: any, callback: any) =&gt; {
  const feed = await photon.posts.findMany()
  callback(null, { feed })
}
</code></pre>

<p>Now let&rsquo;s implement the <code>getPost</code> method, which gets passed a call object and has the <code>id</code> parameter as a property, and a callback to which we can pass our returned post, filtered by the <code>id</code>, from Photon&rsquo;s <code>findOne</code> method for the <code>Post</code> model, with a null first parameter to indicate that there is no error:</p>

<pre><code class="language-ts">const getPost = async(call: any, callback: any) =&gt; {
  const { id } = call.request
  const post = await photon.posts.findOne({
    where: {
      id,
    },
  })
  callback(null, { post })
}
</code></pre>

<p>After implementing the methods defined in our interface, let&rsquo;s run a gRPC server to listen for requests and return responses for our blog service:</p>

<pre><code class="language-ts">const server = new grpc.Server()
server.addService(protoDescriptor.Blog.service, {
  showFeed,
  getPost,
  signupUser,
  createPost,
})
server.bind('0.0.0.0:50051', grpc.ServerCredentials.createInsecure())
server.start()
</code></pre>

<p>Things to note:
- we created an instance of the server by calling the gRPC server constructor
- our service descriptor, which is a property of <code>protoDescriptor.Blog.service</code> is used to create the server
- we implemented the service methods
- we specified the address and port we want to use to listen for client requests using the server instance’s <code>bind</code> method</p>

<h3 id="6-2-write-our-client">6.2 Write our client</h3>

<p>For our <a href="https://gitlab.com/infoverload/grpc-server-client/blob/master/client.ts">client</a>, we have a local object that implements the same methods as the service. The client can then just call those methods on the local object and gRPC looks after sending the requests to the server and returning the server’s protocol buffer responses.</p>

<p>We will load our <code>.proto</code> file the same as we did for our server.</p>

<p>To call service methods, we first need to create a client. To do this, we just need to call the Blog client constructor, specifying the server address and port.</p>

<pre><code class="language-ts">const client = new protoDescriptor.Blog('localhost:50051', grpc.credentials.createInsecure()
</code></pre>

<p>Let&rsquo;s call our RPC <code>getPost</code> method on our local client and pass in an <code>id</code> object and a callback into the request:</p>

<pre><code class="language-ts">  const id = ''
  client.getPost(id, (err: any, response: any) =&gt; {
    if (err) {
      console.error(err)
      return
    }
    console.log(response)
  })
</code></pre>

<p>If there is no error, we can get the response from the server in our callback object.</p>

<h2 id="7-set-up-our-typescript-project">7. Set up our TypeScript project</h2>

<h3 id="7-1-initialize-our-project-and-install-dependencies">7.1. Initialize our project and install dependencies</h3>

<p>Let&rsquo;s set up a basic TypeScript app with <code>npm</code>.</p>

<p>Initialize a new npm project: <code>npm init -y</code></p>

<p>Install typescript and ts-node locally: <code>npm install --save-dev typescript ts-node</code></p>

<h3 id="7-2-add-typescript-configuration">7.2. Add TypeScript configuration</h3>

<p>Create <a href="https://gitlab.com/infoverload/grpc-server-client/blob/master/tsconfig.json">tsconfig.json</a> in our project root and add:</p>

<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;sourceMap&quot;: true,
    &quot;outDir&quot;: &quot;dist&quot;,
    &quot;lib&quot;: [&quot;esnext&quot;, &quot;dom&quot;],
    &quot;strict&quot;: true
  }
}
</code></pre>

<h3 id="7-3-add-a-start-script-to-package-json">7.3. Add a start script to <code>package.json</code></h3>

<p>In our <a href="https://gitlab.com/infoverload/grpc-server-client/blob/master/package.json">package.json</a>, let&rsquo;s add some scripts :</p>

<pre><code class="language-json">&quot;scripts&quot;: {
  &quot;seed&quot;: &quot;ts-node prisma/seed.ts&quot;,
  &quot;server&quot;: &quot;ts-node server.ts&quot;,
  &quot;client&quot;: &quot;ts-node client.ts&quot;
}
</code></pre>

<h3 id="7-4-access-your-database-with-photon">7.4. Access your database with Photon</h3>

<p>You can interact with your database with Photon with a basic <a href="https://gitlab.com/infoverload/grpc-server-client/blob/master/prisma/seed.ts">script</a> following this pattern:</p>

<pre><code class="language-ts">import Photon from '@generated/photon'
const photon = new Photon()

async function main() {

  await photon.connect()  // Open connection to database

  // Access your database with Photon

  await photon.disconnect()  // Close connection to database
}
main()
</code></pre>

<h3 id="7-5-run-the-project">7.5 Run the project</h3>

<p>With everything in place, you can run the project!</p>

<ul>
<li>Seed your database: <code>npm start</code></li>
<li>Run your gRPC server: <code>npm server</code></li>
<li>Run your gRPC client: <code>npm client</code></li>
</ul>

<p>If you prefer a GUI client, try <a href="https://github.com/uw-labs/bloomrpc">BloomRPC</a>.</p>

<p>If you run into problems with this tutorial or spot any mistakes, feel free to make a pull request! :)</p>

                </div>
                <div class="feat share">
                    <a href="//twitter.com/share" class="popup">
                        <span class="icon-twitter"></span>
                    </a>
                </div>
                
                

                
                
                    <a rel="prev" href="https://infoverload.github.io/2019/02/20/exploring-kubernetes-and-helm/" id="prev">
                        &larr; <span class="nav-title nav-title-prev">Older</span>
                    </a>
                
            </article>
        </section>

        <footer>
	
	<small>Powered by <a href="//gohugo.io">HUGO</a> - © 2018</small>
	
</footer>
    </div>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="https://infoverload.github.io/js/main.js"></script>




<!-- Syntax highlighting -->
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
